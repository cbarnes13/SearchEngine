<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>BSSearch: string_util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BSSearch
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">string_util Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__util_1_1equal__string__i__compare.html">equal_string_i_compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__util_1_1equal__basic__string__i__compare.html">equal_basic_string_i_compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__util_1_1equal__string__compare.html">equal_string_compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__util_1_1less__string__n__compare.html">less_string_n_compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__util_1_1less__string__ni__compare.html">less_string_ni_compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__util_1_1less__string__i__compare.html">less_string_i_compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__util_1_1less__string__compare.html">less_string_compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__util_1_1less__basic__string__compare.html">less_basic_string_compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__util_1_1less__string__natural__order__i__compare.html">less_string_natural_order_i_compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__util_1_1string__trim.html">string_trim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">trims whitespace from around a string  <a href="classstring__util_1_1string__trim.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__util_1_1string__tokenize.html">string_tokenize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a65ecd19fe84afd9cff4f1715f9364141"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65ecd19fe84afd9cff4f1715f9364141"></a>
wchar_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a65ecd19fe84afd9cff4f1715f9364141">tolower_western</a> (const wchar_t c)</td></tr>
<tr class="memdesc:a65ecd19fe84afd9cff4f1715f9364141"><td class="mdescLeft">&#160;</td><td class="mdescRight">lowercases any Western European alphabetic characters <br/></td></tr>
<tr class="separator:a65ecd19fe84afd9cff4f1715f9364141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a24858b465560e8f0b083d2fa80ce4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a27a24858b465560e8f0b083d2fa80ce4">strtol</a> (const char *str, char **strend, int radix)</td></tr>
<tr class="separator:a27a24858b465560e8f0b083d2fa80ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acf272c0e68f0b5f2381ad59db3055c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6acf272c0e68f0b5f2381ad59db3055c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>strtol</b> (const wchar_t *str, wchar_t **strend, int radix)</td></tr>
<tr class="separator:a6acf272c0e68f0b5f2381ad59db3055c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563de3552dde86286bcff20cfaac49a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a563de3552dde86286bcff20cfaac49a9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a563de3552dde86286bcff20cfaac49a9">strtod</a> (const char *str, char **strend)</td></tr>
<tr class="memdesc:a563de3552dde86286bcff20cfaac49a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">strtod <br/></td></tr>
<tr class="separator:a563de3552dde86286bcff20cfaac49a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75191bc768437cc444054667f18af344"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75191bc768437cc444054667f18af344"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>strtod</b> (const wchar_t *str, wchar_t **strend)</td></tr>
<tr class="separator:a75191bc768437cc444054667f18af344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6fc44dacb428d9928401574d5bc819"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf6fc44dacb428d9928401574d5bc819"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#adf6fc44dacb428d9928401574d5bc819">atoi</a> (const char *str)</td></tr>
<tr class="memdesc:adf6fc44dacb428d9928401574d5bc819"><td class="mdescLeft">&#160;</td><td class="mdescRight">atoi <br/></td></tr>
<tr class="separator:adf6fc44dacb428d9928401574d5bc819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2cd4dfa1c657252314e26c608a835c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f2cd4dfa1c657252314e26c608a835c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>atoi</b> (const wchar_t *str)</td></tr>
<tr class="separator:a4f2cd4dfa1c657252314e26c608a835c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99328118377e46b338d4008931489f0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99328118377e46b338d4008931489f0b"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a99328118377e46b338d4008931489f0b">atol</a> (const char *str)</td></tr>
<tr class="memdesc:a99328118377e46b338d4008931489f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">atol <br/></td></tr>
<tr class="separator:a99328118377e46b338d4008931489f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ace5ad59eefb2ad3aa290ff6ee45dcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ace5ad59eefb2ad3aa290ff6ee45dcd"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>atol</b> (const wchar_t *str)</td></tr>
<tr class="separator:a4ace5ad59eefb2ad3aa290ff6ee45dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4f0e0cc9d5260ee988dd629be5cf33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe4f0e0cc9d5260ee988dd629be5cf33"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#abe4f0e0cc9d5260ee988dd629be5cf33">tolower</a> (char c)</td></tr>
<tr class="memdesc:abe4f0e0cc9d5260ee988dd629be5cf33"><td class="mdescLeft">&#160;</td><td class="mdescRight">tolower <br/></td></tr>
<tr class="separator:abe4f0e0cc9d5260ee988dd629be5cf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1472adfdc7d01583d9608ac28ffe43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a1472adfdc7d01583d9608ac28ffe43"></a>
wchar_t&#160;</td><td class="memItemRight" valign="bottom"><b>tolower</b> (wchar_t c)</td></tr>
<tr class="separator:a1a1472adfdc7d01583d9608ac28ffe43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69a7a0bcec3adae0a307357922c324b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad69a7a0bcec3adae0a307357922c324b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#ad69a7a0bcec3adae0a307357922c324b">toupper</a> (char c)</td></tr>
<tr class="memdesc:ad69a7a0bcec3adae0a307357922c324b"><td class="mdescLeft">&#160;</td><td class="mdescRight">toupper <br/></td></tr>
<tr class="separator:ad69a7a0bcec3adae0a307357922c324b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851103e5ef3d3ab575f8aa92d213fa42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a851103e5ef3d3ab575f8aa92d213fa42"></a>
wchar_t&#160;</td><td class="memItemRight" valign="bottom"><b>toupper</b> (wchar_t c)</td></tr>
<tr class="separator:a851103e5ef3d3ab575f8aa92d213fa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca68d7c6c61eaa4a378fdaa016f2e13"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6ca68d7c6c61eaa4a378fdaa016f2e13"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ca68d7c6c61eaa4a378fdaa016f2e13"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a6ca68d7c6c61eaa4a378fdaa016f2e13">memset</a> (T *dest, int c, size_t count)</td></tr>
<tr class="memdesc:a6ca68d7c6c61eaa4a378fdaa016f2e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">memset <br/></td></tr>
<tr class="separator:a6ca68d7c6c61eaa4a378fdaa016f2e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6bd4ad0f654fff0a4ee630f1326640"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a6bd4ad0f654fff0a4ee630f1326640"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>memset</b> (char *dest, int c, size_t count)</td></tr>
<tr class="separator:a4a6bd4ad0f654fff0a4ee630f1326640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860f9c92e013f2863060669bbe05973b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a860f9c92e013f2863060669bbe05973b"></a>
wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>memset</b> (wchar_t *dest, int c, size_t count)</td></tr>
<tr class="separator:a860f9c92e013f2863060669bbe05973b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88a0930241b7add7546b649ebec855d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa88a0930241b7add7546b649ebec855d"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#aa88a0930241b7add7546b649ebec855d">strchr</a> (const char *s, int ch)</td></tr>
<tr class="memdesc:aa88a0930241b7add7546b649ebec855d"><td class="mdescLeft">&#160;</td><td class="mdescRight">strchr <br/></td></tr>
<tr class="separator:aa88a0930241b7add7546b649ebec855d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70588ea01a35282892b8f0c281a5bb1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70588ea01a35282892b8f0c281a5bb1c"></a>
const wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>strchr</b> (const wchar_t *s, wchar_t ch)</td></tr>
<tr class="separator:a70588ea01a35282892b8f0c281a5bb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b1bffbbcea43e28d6f821a69f89a4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38b1bffbbcea43e28d6f821a69f89a4b"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a38b1bffbbcea43e28d6f821a69f89a4b">strstr</a> (const char *s1, const char *s2)</td></tr>
<tr class="memdesc:a38b1bffbbcea43e28d6f821a69f89a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">strstr <br/></td></tr>
<tr class="separator:a38b1bffbbcea43e28d6f821a69f89a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6bbad266f06165b7e306039b73ba6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee6bbad266f06165b7e306039b73ba6d"></a>
const wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>strstr</b> (const wchar_t *s1, const wchar_t *s2)</td></tr>
<tr class="separator:aee6bbad266f06165b7e306039b73ba6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8e7142b076ef57e4dc89f329c828fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d8e7142b076ef57e4dc89f329c828fe"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a9d8e7142b076ef57e4dc89f329c828fe">strcspn</a> (const char *string1, const char *string2)</td></tr>
<tr class="memdesc:a9d8e7142b076ef57e4dc89f329c828fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">strcspn <br/></td></tr>
<tr class="separator:a9d8e7142b076ef57e4dc89f329c828fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec3237ea3ddec88e683b0b418383b27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ec3237ea3ddec88e683b0b418383b27"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>strcspn</b> (const wchar_t *string1, const wchar_t *string2)</td></tr>
<tr class="separator:a2ec3237ea3ddec88e683b0b418383b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215cc7e648621d719631efdb01b6d273"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a215cc7e648621d719631efdb01b6d273"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a215cc7e648621d719631efdb01b6d273">strncat</a> (char *strDest, const char *strSource, size_t count)</td></tr>
<tr class="memdesc:a215cc7e648621d719631efdb01b6d273"><td class="mdescLeft">&#160;</td><td class="mdescRight">strncat <br/></td></tr>
<tr class="separator:a215cc7e648621d719631efdb01b6d273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafd341e0b88e2a0241e009da695c712"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaafd341e0b88e2a0241e009da695c712"></a>
wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>strncat</b> (wchar_t *strDest, const wchar_t *strSource, size_t count)</td></tr>
<tr class="separator:aaafd341e0b88e2a0241e009da695c712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1ce3a13f15c1bbbccdc8120e9f2ee3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d1ce3a13f15c1bbbccdc8120e9f2ee3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a5d1ce3a13f15c1bbbccdc8120e9f2ee3">wctomb</a> (wchar_t *s, wchar_t wc)</td></tr>
<tr class="memdesc:a5d1ce3a13f15c1bbbccdc8120e9f2ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">wctomb <br/></td></tr>
<tr class="separator:a5d1ce3a13f15c1bbbccdc8120e9f2ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac014cd94ca1a47bde507f4dcc2057172"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac014cd94ca1a47bde507f4dcc2057172"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>wctomb</b> (char *s, wchar_t wc)</td></tr>
<tr class="separator:ac014cd94ca1a47bde507f4dcc2057172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733d7b92d48889fe1ee684a43ccf0095"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a733d7b92d48889fe1ee684a43ccf0095"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>strlen</b> (const char *text)</td></tr>
<tr class="separator:a733d7b92d48889fe1ee684a43ccf0095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8e108eb4f1d08b81118bb54d930b90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf8e108eb4f1d08b81118bb54d930b90"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>strlen</b> (const wchar_t *text)</td></tr>
<tr class="separator:aaf8e108eb4f1d08b81118bb54d930b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791b8d128151f4485bf887bf438b691f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a791b8d128151f4485bf887bf438b691f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a791b8d128151f4485bf887bf438b691f">strcmp</a> (const char *string1, const char *string2)</td></tr>
<tr class="memdesc:a791b8d128151f4485bf887bf438b691f"><td class="mdescLeft">&#160;</td><td class="mdescRight">strcmp <br/></td></tr>
<tr class="separator:a791b8d128151f4485bf887bf438b691f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56913f0992f2e3873742dfed7a3a139"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac56913f0992f2e3873742dfed7a3a139"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>strcmp</b> (const wchar_t *string1, const wchar_t *string2)</td></tr>
<tr class="separator:ac56913f0992f2e3873742dfed7a3a139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5007e89fd173108517cd5d6b0b9366c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5007e89fd173108517cd5d6b0b9366c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#ae5007e89fd173108517cd5d6b0b9366c">strncmp</a> (const char *string1, const char *string2, size_t count)</td></tr>
<tr class="memdesc:ae5007e89fd173108517cd5d6b0b9366c"><td class="mdescLeft">&#160;</td><td class="mdescRight">strncmp <br/></td></tr>
<tr class="separator:ae5007e89fd173108517cd5d6b0b9366c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228b9144a3fca764257878d37ac774a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a228b9144a3fca764257878d37ac774a3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>strncmp</b> (const wchar_t *string1, const wchar_t *string2, size_t count)</td></tr>
<tr class="separator:a228b9144a3fca764257878d37ac774a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955d4ceed010c00aa6b32eadface6558"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a955d4ceed010c00aa6b32eadface6558"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a955d4ceed010c00aa6b32eadface6558">strncpy</a> (char *strDest, const char *strSource, size_t count)</td></tr>
<tr class="memdesc:a955d4ceed010c00aa6b32eadface6558"><td class="mdescLeft">&#160;</td><td class="mdescRight">strncpy <br/></td></tr>
<tr class="separator:a955d4ceed010c00aa6b32eadface6558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7719a68a6781593c89931225aaf73a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c7719a68a6781593c89931225aaf73a"></a>
wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>strncpy</b> (wchar_t *strDest, const wchar_t *strSource, size_t count)</td></tr>
<tr class="separator:a5c7719a68a6781593c89931225aaf73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c0e55cfd7dd74b275abd8f00d0bbd9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad8c0e55cfd7dd74b275abd8f00d0bbd9"></a>
template&lt;typename charT &gt; </td></tr>
<tr class="memitem:ad8c0e55cfd7dd74b275abd8f00d0bbd9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#ad8c0e55cfd7dd74b275abd8f00d0bbd9">itoa</a> (long value, charT *out, const size_t length)</td></tr>
<tr class="memdesc:ad8c0e55cfd7dd74b275abd8f00d0bbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">functions not available in ANSI C <br/></td></tr>
<tr class="separator:ad8c0e55cfd7dd74b275abd8f00d0bbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93be700ec46644ae01efc6fda56b950"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af93be700ec46644ae01efc6fda56b950"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#af93be700ec46644ae01efc6fda56b950">is_space</a> (const T ch)</td></tr>
<tr class="separator:af93be700ec46644ae01efc6fda56b950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c723187df1b5450e8c106ecb04a10a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8c723187df1b5450e8c106ecb04a10a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#af8c723187df1b5450e8c106ecb04a10a">is_hex_digit</a> (const T ch)</td></tr>
<tr class="separator:af8c723187df1b5450e8c106ecb04a10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e03e7a1706cfacce0cacc35f938f53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6e03e7a1706cfacce0cacc35f938f53"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#ae6e03e7a1706cfacce0cacc35f938f53">axtoi</a> (const T *hexStr, size_t length=-1)</td></tr>
<tr class="separator:ae6e03e7a1706cfacce0cacc35f938f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6168510fd7ef18b0cf0a5d6c6e4e42"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad6168510fd7ef18b0cf0a5d6c6e4e42"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#aad6168510fd7ef18b0cf0a5d6c6e4e42">strnlen</a> (const T *str, const size_t maxlen)</td></tr>
<tr class="separator:aad6168510fd7ef18b0cf0a5d6c6e4e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefacc16446da64a7897ef698f5006b6e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aefacc16446da64a7897ef698f5006b6e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aefacc16446da64a7897ef698f5006b6e"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#aefacc16446da64a7897ef698f5006b6e">stristr</a> (const T *string, const T *strSearch)</td></tr>
<tr class="memdesc:aefacc16446da64a7897ef698f5006b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">search for substring in string (case-insensitive) <br/></td></tr>
<tr class="separator:aefacc16446da64a7897ef698f5006b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681a562526aa0d84c5aecc31871d52ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a681a562526aa0d84c5aecc31871d52ac"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a681a562526aa0d84c5aecc31871d52ac">strnistr</a> (const T *string, const T *strSearch, const size_t string_len)</td></tr>
<tr class="separator:a681a562526aa0d84c5aecc31871d52ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c632047571bec6063ca6316b78baff5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c632047571bec6063ca6316b78baff5"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a9c632047571bec6063ca6316b78baff5">strrstr</a> (const T *string, const T *search, size_t offset)</td></tr>
<tr class="separator:a9c632047571bec6063ca6316b78baff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab636487921427be3e286cc5cd46e6cc5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab636487921427be3e286cc5cd46e6cc5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab636487921427be3e286cc5cd46e6cc5"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#ab636487921427be3e286cc5cd46e6cc5">strnicmp</a> (const T *first, const T *last, size_t count)</td></tr>
<tr class="memdesc:ab636487921427be3e286cc5cd46e6cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case-insensitive comparison by character count. <br/></td></tr>
<tr class="separator:ab636487921427be3e286cc5cd46e6cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e8f2f285edc9abd73199db60dc589a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a11e8f2f285edc9abd73199db60dc589a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11e8f2f285edc9abd73199db60dc589a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a11e8f2f285edc9abd73199db60dc589a">stricmp</a> (const T *first, const T *last)</td></tr>
<tr class="memdesc:a11e8f2f285edc9abd73199db60dc589a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case-insensitive comparison. <br/></td></tr>
<tr class="separator:a11e8f2f285edc9abd73199db60dc589a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b96d421c7531d6af096e2b6f2b19b6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b96d421c7531d6af096e2b6f2b19b6a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a2b96d421c7531d6af096e2b6f2b19b6a">strnatordcmp</a> (const T *first_string, const T *second_string, bool case_insensitive=false)</td></tr>
<tr class="separator:a2b96d421c7531d6af096e2b6f2b19b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde462ee1fa10e25dee2010cc9b3d500"><td class="memTemplParams" colspan="2"><a class="anchor" id="abde462ee1fa10e25dee2010cc9b3d500"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abde462ee1fa10e25dee2010cc9b3d500"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#abde462ee1fa10e25dee2010cc9b3d500">strnatordncasecmp</a> (const T *a, const T *b)</td></tr>
<tr class="memdesc:abde462ee1fa10e25dee2010cc9b3d500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare, recognizing numeric strings and ignoring case. <br/></td></tr>
<tr class="separator:abde462ee1fa10e25dee2010cc9b3d500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5872d5326e0b533b26919bbf5164a569"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5872d5326e0b533b26919bbf5164a569"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a5872d5326e0b533b26919bbf5164a569">has_suffix</a> (const T *text, const size_t text_length, const T *suffix, const size_t suffix_length)</td></tr>
<tr class="separator:a5872d5326e0b533b26919bbf5164a569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec324c3f924477c042945e350ce9164f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec324c3f924477c042945e350ce9164f"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#aec324c3f924477c042945e350ce9164f">find_matching_close_tag</a> (const T *string, const T openSymbol, const T closeSymbol, const bool fail_on_overlapping_open_symbol=false)</td></tr>
<tr class="separator:aec324c3f924477c042945e350ce9164f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca49ee9759c52a930b15816f643f1085"><td class="memTemplParams" colspan="2"><a class="anchor" id="aca49ee9759c52a930b15816f643f1085"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca49ee9759c52a930b15816f643f1085"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#aca49ee9759c52a930b15816f643f1085">find_matching_close_tag</a> (const T *string, const T *openSymbol, const T *closeSymbol)</td></tr>
<tr class="memdesc:aca49ee9759c52a930b15816f643f1085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a matching tag, skipping an extra open/close pairs of symbols in between. <br/></td></tr>
<tr class="separator:aca49ee9759c52a930b15816f643f1085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80a08ee0c58d8e159cb7524e23f0959"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac80a08ee0c58d8e159cb7524e23f0959"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#ac80a08ee0c58d8e159cb7524e23f0959">strnchr</a> (const T *string, const T ch, size_t size)</td></tr>
<tr class="separator:ac80a08ee0c58d8e159cb7524e23f0959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04954fbf48eee3f46463fd14e4a7d1a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa04954fbf48eee3f46463fd14e4a7d1a"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#aa04954fbf48eee3f46463fd14e4a7d1a">strcspn_pointer</a> (const T *string1, const T *string2, const size_t string2Length)</td></tr>
<tr class="separator:aa04954fbf48eee3f46463fd14e4a7d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f36e95c675fb109d6d042bff7cc0487"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f36e95c675fb109d6d042bff7cc0487"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a1f36e95c675fb109d6d042bff7cc0487">strncspn</a> (const T *stringToSearch, const size_t stringToSearchLength, const T *searchString, const size_t searchStringLength)</td></tr>
<tr class="separator:a1f36e95c675fb109d6d042bff7cc0487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5dbb55649fe7c47191857735b7319e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2d5dbb55649fe7c47191857735b7319e"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a2d5dbb55649fe7c47191857735b7319e">find_last_not_of</a> (const T *string, const T *search, size_t offset=std::basic_string&lt; T &gt;::npos)</td></tr>
<tr class="separator:a2d5dbb55649fe7c47191857735b7319e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef82fb380f5c370be7f1aad3ba2d86cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef82fb380f5c370be7f1aad3ba2d86cb"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#aef82fb380f5c370be7f1aad3ba2d86cb">find_last_of</a> (const T *string, const T ch, size_t offset=-1)</td></tr>
<tr class="separator:aef82fb380f5c370be7f1aad3ba2d86cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2321452d97ffab53b920bf86398148"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3d2321452d97ffab53b920bf86398148"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d2321452d97ffab53b920bf86398148"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_first_not_of</b> (const T *stringToSearch, const size_t stringToSearchLength, const T *searchString, const size_t searchStringLength)</td></tr>
<tr class="separator:a3d2321452d97ffab53b920bf86398148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac601c12172781e135da65305c87bfd50"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac601c12172781e135da65305c87bfd50"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac601c12172781e135da65305c87bfd50"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#ac601c12172781e135da65305c87bfd50">remove_all_whitespace</a> (const T &amp;text)</td></tr>
<tr class="memdesc:ac601c12172781e135da65305c87bfd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all whitespace from a string. <br/></td></tr>
<tr class="separator:ac601c12172781e135da65305c87bfd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f89ea80d36d58f12a5b156aa91d43aa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f89ea80d36d58f12a5b156aa91d43aa"></a>
template&lt;typename Tchar_type , typename T &gt; </td></tr>
<tr class="memitem:a2f89ea80d36d58f12a5b156aa91d43aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a2f89ea80d36d58f12a5b156aa91d43aa">remove_all</a> (T &amp;text, Tchar_type char_to_replace)</td></tr>
<tr class="memdesc:a2f89ea80d36d58f12a5b156aa91d43aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all instances of a character from a string. <br/></td></tr>
<tr class="separator:a2f89ea80d36d58f12a5b156aa91d43aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ec640d61f1209f2e47cd91504061d3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a10ec640d61f1209f2e47cd91504061d3"></a>
template&lt;typename Tchar_type , typename T &gt; </td></tr>
<tr class="memitem:a10ec640d61f1209f2e47cd91504061d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a10ec640d61f1209f2e47cd91504061d3">replace_all</a> (T &amp;text, Tchar_type text_to_replace, Tchar_type replacement_text)</td></tr>
<tr class="memdesc:a10ec640d61f1209f2e47cd91504061d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper functions for stemmers <br/></td></tr>
<tr class="separator:a10ec640d61f1209f2e47cd91504061d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066971cc89a67e380df6098d90237ff2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a066971cc89a67e380df6098d90237ff2"></a>
template&lt;typename T , typename Tchar_type &gt; </td></tr>
<tr class="memitem:a066971cc89a67e380df6098d90237ff2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>replace_all</b> (T &amp;text, const Tchar_type *text_to_replace, const Tchar_type *replacement_text)</td></tr>
<tr class="separator:a066971cc89a67e380df6098d90237ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd789a33fdd13f1b7de04904d164d413"><td class="memTemplParams" colspan="2"><a class="anchor" id="abd789a33fdd13f1b7de04904d164d413"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd789a33fdd13f1b7de04904d164d413"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>replace_all</b> (T &amp;text, const T &amp;text_to_replace, const T &amp;replacement_text)</td></tr>
<tr class="separator:abd789a33fdd13f1b7de04904d164d413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e32e326c342905e91ab0025292f039"><td class="memTemplParams" colspan="2">template&lt;typename string_typeT &gt; </td></tr>
<tr class="memitem:ac2e32e326c342905e91ab0025292f039"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#ac2e32e326c342905e91ab0025292f039">remove_extra_spaces</a> (string_typeT &amp;Text)</td></tr>
<tr class="separator:ac2e32e326c342905e91ab0025292f039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25307ecbc1d55724e503c7da9a5720ae"><td class="memTemplParams" colspan="2">template&lt;typename string_typeT &gt; </td></tr>
<tr class="memitem:a25307ecbc1d55724e503c7da9a5720ae"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#a25307ecbc1d55724e503c7da9a5720ae">remove_blank_lines</a> (string_typeT &amp;Text)</td></tr>
<tr class="separator:a25307ecbc1d55724e503c7da9a5720ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14cb6f2828d7c49aee300734c38239c"><td class="memTemplParams" colspan="2">template&lt;typename Tchar_type &gt; </td></tr>
<tr class="memitem:ad14cb6f2828d7c49aee300734c38239c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestring__util.html#ad14cb6f2828d7c49aee300734c38239c">strtod_ex</a> (const Tchar_type *nptr, Tchar_type **endptr)</td></tr>
<tr class="separator:ad14cb6f2828d7c49aee300734c38239c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2a992607751ea675fb9e45c348a71d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2c2a992607751ea675fb9e45c348a71d"></a>
template&lt;typename Tchar_type &gt; </td></tr>
<tr class="memitem:a2c2a992607751ea675fb9e45c348a71d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_one_of</b> (const Tchar_type character, const Tchar_type *char_string)</td></tr>
<tr class="separator:a2c2a992607751ea675fb9e45c348a71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section date"><dt>Date</dt><dd>2003-2015 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Oleander Software, Ltd. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Oleander Software, Ltd.</dd></dl>
<p>This program is free software; you can redistribute it and/or modify it under the terms of the BSD License. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae6e03e7a1706cfacce0cacc35f938f53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int string_util::axtoi </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>hexStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts string in hex format to int. Default figures out how much of the string is a valid hex string, but passing a value to the second parameter overrides this and allows you to indicate how much of the string to try to convert. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hexStr</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> string to convert.  How much of the string to analyze. <a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> value -1 (the default) will tell the function to read until there are no more valid hexadecimal digits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> value of the string as an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d5dbb55649fe7c47191857735b7319e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t string_util::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>std::basic_string&lt;T&gt;::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>search for a single character not from a sequence in a string in reverse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> string to search in. </td></tr>
    <tr><td class="paramname">search</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> sequence of characters to skip. </td></tr>
    <tr><td class="paramname">offset</td><td>Where to begin the search. If -1, then the reverse search will begin at the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the position of where the last non-matching character is at, or -1 if it can't be found. </dd></dl>

</div>
</div>
<a class="anchor" id="aef82fb380f5c370be7f1aad3ba2d86cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t string_util::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>search for the last instance of a character in a string in reverse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> string to search. </td></tr>
    <tr><td class="paramname">ch</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> character to search for. </td></tr>
    <tr><td class="paramname">offset</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> offset in the string to begin the search from. <a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> default (-1) will begin the search at the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> offset of the found character, or -1 if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="aec324c3f924477c042945e350ce9164f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* string_util::find_matching_close_tag </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>openSymbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>closeSymbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fail_on_overlapping_open_symbol</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for a matching tag, skipping an extra open/close pairs of symbols in between. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">openSymbol</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> opening symbol. </td></tr>
    <tr><td class="paramname">closeSymbol</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> closing symbol that we are looking for. </td></tr>
    <tr><td class="paramname">fail_on_overlapping_open_symbol</td><td>Whether it should immediately return failure if an open symbol is found before a matching close symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to where the closing tag is, or NULL if one can't be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a5872d5326e0b533b26919bbf5164a569"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool string_util::has_suffix </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>text_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>suffix_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates whether a larger strings ends with the specified suffix. Lengths are provided by the caller for efficiency. This function is case sensitive. </p>

</div>
</div>
<a class="anchor" id="af8c723187df1b5450e8c106ecb04a10a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool string_util::is_hex_digit </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines whether a character is a hexademical digit (0-9,A-F,a-f). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> letter to be analyzed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af93be700ec46644ae01efc6fda56b950"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool string_util::is_space </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines whether a character is a space, tab, or newline. Also includes double-width and no break spaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> letter to be analyzed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25307ecbc1d55724e503c7da9a5720ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename string_typeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t string_util::remove_blank_lines </td>
          <td>(</td>
          <td class="paramtype">string_typeT &amp;&#160;</td>
          <td class="paramname"><em>Text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes blank lines from a block of text </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Text</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> text to have blank lines removed from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters (not lines) removed from the block. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2e32e326c342905e91ab0025292f039"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename string_typeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t string_util::remove_extra_spaces </td>
          <td>(</td>
          <td class="paramtype">string_typeT &amp;&#160;</td>
          <td class="paramname"><em>Text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>strips extraneous spaces/tabs/carriage returns from a block of text so that there isn't more than one space consecutively. </p>

</div>
</div>
<a class="anchor" id="aa04954fbf48eee3f46463fd14e4a7d1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* string_util::strcspn_pointer </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>string1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>string2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>string2Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>search for a single character from a sequence in a string and return a pointer if found. </p>

</div>
</div>
<a class="anchor" id="a2b96d421c7531d6af096e2b6f2b19b6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int string_util::strnatordcmp </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>first_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>second_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>case_insensitive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Natural order comparison functions. Compare, recognizing numeric strings. </p>

</div>
</div>
<a class="anchor" id="ac80a08ee0c58d8e159cb7524e23f0959"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* string_util::strnchr </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for a single character in a string for n number of characters. Size argument should be less than or equal to the length of the string being searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> string to search in. </td></tr>
    <tr><td class="paramname">ch</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> character to search for. </td></tr>
    <tr><td class="paramname">size</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> size of the search string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer in the string where the character was found, or NULL if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f36e95c675fb109d6d042bff7cc0487"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t string_util::strncspn </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>stringToSearch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>stringToSearchLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>searchStringLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for a single character from a sequence in a string for n number of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stringToSearch</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> string to search. </td></tr>
    <tr><td class="paramname">stringToSearchLength</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> length of the string being searched. </td></tr>
    <tr><td class="paramname">searchString</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> sequence of characters to search for. </td></tr>
    <tr><td class="paramname">searchStringLength</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> length of the sequence string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> index into the string that the character was found. Returns the length of the string if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a681a562526aa0d84c5aecc31871d52ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* string_util::strnistr </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>strSearch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>string_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for substring in a larger string (case-insensitively), limiting the search to a specified number of characters. </p>

</div>
</div>
<a class="anchor" id="aad6168510fd7ef18b0cf0a5d6c6e4e42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t string_util::strnlen </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of characters in the string pointed to by str, not including the terminating '\0' character, but at most maxlen. In doing this, strnlen looks only at the first maxlen characters at str and never beyond str+maxlen. This function should be used for input that may not be NULL terminated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> string to review. </td></tr>
    <tr><td class="paramname">maxlen</td><td><a class="el" href="class_the.html" title="Singly linked list that has nodes that contain the page number, term frequency, document title...">The</a> maximum length of the string to scan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the valid length of the string or maxlen, whichever is shorter. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c632047571bec6063ca6316b78baff5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* string_util::strrstr </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search string in reverse for substring. "offset" is how far we are in the source string already and how far to go back. </p>

</div>
</div>
<a class="anchor" id="ad14cb6f2828d7c49aee300734c38239c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tchar_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double string_util::strtod_ex </td>
          <td>(</td>
          <td class="paramtype">const Tchar_type *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tchar_type **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts strings to double values, but also takes into account ranges (returning the average). For example, a string like "5-8" will return 6.5. Hyphens and colons are seen as range separators. </p>

</div>
</div>
<a class="anchor" id="a27a24858b465560e8f0b083d2fa80ce4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double string_util::strtol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>strend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ANSI C decorators strtol </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 7 2015 02:28:50 for BSSearch by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
